
CONTENTS OF THIS FILE
-------------------------------------------------------------------------------
* Program Information
* Introduction
* Program Elements
* Compilation and Usage
* Design
* Conclusion

-------------------------------------------------------------------------------
 Introduction
-------------------------------------------------------------------------------

This is a simple UDP-based client and server program implementing basic network security principles. Client-side, the user program sends multpile passwords of length N (typically 1 - 4, but up to 8 in this case) of a given set of characters to the server program in order to guess a pre-determiend password. 

The server program makes up the password, also of length N, and with the same set of characters. The server may make this password up randomly or take in an initial password from the command line.

The server runs indefinetly, allowing it to handle multiple clients. After a client successfully guesses the password, the server generates a new password randomly and waits for the next client.

The client runs until it either guesses the password, is terminated by the user (CTRL-C), or times out (in this case, we have configured the time-out to be 1.5 seconds).

Upon termination, the client program and server program print multiple statstics and facts about the session.

-------------------------------------------------------------------------------
 PROGRAM ELEMENTS
-------------------------------------------------------------------------------
 * passwordBreaker.c

 The client program. This generates all possible passwords of length N from a set of K characters and guesses each one to the server program until it receives a success, times out, or is terminated by the user.

 * passwordServer.c

  The server program. This program has at any point one uniquely generated password of length N from the same set of K characters as the client. The server handles one client at a time while it guesses the password. Upon success, resets password and awaits for a new client.

 * password.h

  Header file for all .c files. Includes pertinent libraries and constants (such as the max length of a password, which is 8 in this implementation).

 * password.c

  A .c file corresponding to the password.h file. This does not serve any purpose in technically finding the password, per se. Necessary for compilation.

 * allPasswords.txt

  A text file generated by the client used to keep track of visited passwords and remaining possible passwords.

 * makefile

  A file used to compile the programs in a systematic way.

 * Make.defines

  This file helps artiuclate the makefile.

-------------------------------------------------------------------------------
 COMPILATION AND USAGE
-------------------------------------------------------------------------------

* Compilation

	issue the following commadns on the terminal:

	make clean
	make

	These commmands use different functions of the make file to first, remove all executables, and second, re-make the executables (that is, the .o files) for running the program. The program should now be compiled and is ready to run.

* Usage

	In one terminal in the hw1 directory, run the following:

	./passwordServer < Port Number > < N > < Initial Password >

	Where...

	* passwordServer is the executable from passwordServer.c
	* Port Numbmer is an available DGRAM port
	* N is an integer 1 - 8 that serves as the password length
	* Initial Password is a password of length N (optional)

	In another termainl in the h1 directory, then run:

	./passwordBreaker < Server IP Addr > < Port Number > < N >

    Where...

	* passwordBreaker is the executable from passwordBreaker.c
	* Server Ip Addr is the internet protocol address of the client computer
	* Port Numbmer is the same available DGRAM port as before
	* N is the same integer used for passwordServer


* Output

	While the client is trying to guess the password with the server, the terminal window will update for the client window if it times out, is terminated by the user, or successfully guesses the server's password. 

	The client will then print out the time the program ran down to the millisecond, the number of attempts it sent the server, and, of course, the password itself.

	Just to revalidate, the server will then reveal the password on this side so the user can validate the outcome. 

	The client terminates at this point. The server continues to run.

	When the server terminates, it will print all the clients it handled.

-------------------------------------------------------------------------------
 DESIGN
-------------------------------------------------------------------------------

This project was designed with simplicity in mind. Therefore, it's not incredibly scalable, but for its performance, at least relatively compact and straightforward.

The server and client programs follow standard routines to maintain server-client connections via UDP-based sockets. The program is not fundamentally profound in any way regarding this implementation.

The specificity of the program comes in how to guess and generate the passwords in a systematic way for the client and server, respectively.

For the server, we use a time-dependent seed to ensure more randomly generated passwords than just using one seed. For the client, on the otherhand, guessing the password by using a randomly generated word won't ensure gaurenteed success.

 Rather, the method generateAllPasswords(n) generates every possible permutation of a password of length n with the given character set. Possible room for improvement lies in the handling of all the password guesses. In this case, all the generated passwords are stuck in a text file and read line-by-line later (ie so we can send one message at a time), to the server to guess the password. This is inefficient because we generate all the passwords before even testing them; ideally we would generate new passwords as we tested them. However, given the magnitude and scope of the program, this increased inefficiency isn't especially debilitating, heuristically speaking.

-------------------------------------------------------------------------------
 CONCLUSION
-------------------------------------------------------------------------------

 While this program has room for improvement (ie, concurrent password generation and testing, bigger character sets, larger Ns, etc...), the program serves as a simple foundation for understanding the basic concepts of UDP socket programming and network security.

 Enjoy!

 Grace Glenn, author
